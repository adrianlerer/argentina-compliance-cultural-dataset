#!/usr/bin/env python3
"""
üöÄ CORRUPTCHA VISUAL CLASSIFICATION üöÄ
Micro-tareas visuales estilo Google CAPTCHA para compliance argentino

Inspirado en el modelo perro/muffin de Google pero para INTEGRIDAD EMPRESARIAL

‚úÖ Visual + Text Classification | ‚úÖ Crowdsourced Training | ‚úÖ Cultural Intelligence
‚úÖ Gamification | ‚úÖ Quality Control | ‚úÖ Revenue Generation

"La IA que entiende c√≥mo hablan los argentinos en los negocios"
"""

import random
import json
import uuid
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import base64
import io

@dataclass
class VisualTask:
    """Tarea visual de clasificaci√≥n CORRUPTCHA"""
    task_id: str
    task_type: str  # "risk_classification", "euphemism_detection", "family_networks"
    question: str
    options: List[Dict[str, Any]]  # Cada opci√≥n tiene texto, imagen opcional, metadata
    correct_answer: Optional[str] = None
    difficulty_level: int = 1  # 1-5
    cultural_context: str = "argentina"
    legal_reference: str = ""
    created_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()

class CorruptchaVisualEngine:
    """
    Motor de clasificaci√≥n visual CORRUPTCHA
    Genera micro-tareas estilo Google perro/muffin pero para compliance
    """
    
    def __init__(self):
        self.task_templates = self._load_task_templates()
        self.cultural_scenarios = self._load_cultural_scenarios()
        self.visual_elements = self._load_visual_elements()
        
        print("üöÄ CORRUPTCHA Visual Engine initialized")
        print("üìä Inspirado en Google perro/muffin para compliance argentino")
    
    def _load_task_templates(self) -> Dict[str, Any]:
        """Cargar templates de tareas visuales"""
        
        return {
            "risk_classification": {
                "question_template": "¬øCu√°l de estas situaciones representa MAYOR riesgo bajo Ley 27.401?",
                "description": "Clasificar nivel de riesgo en situaciones empresariales",
                "options_count": 4,
                "time_limit": 30  # segundos
            },
            "euphemism_detection": {
                "question_template": "¬øCu√°l de estas expresiones es un EUFEMISMO de actividad irregular?",
                "description": "Detectar eufemismos culturales argentinos",
                "options_count": 4,
                "time_limit": 25
            },
            "family_networks": {
                "question_template": "¬øCu√°l indica CONFLICTO DE INTERESES por v√≠nculos familiares?",
                "description": "Identificar redes familiares en contexto empresarial",
                "options_count": 3,
                "time_limit": 20
            },
            "hospitality_assessment": {
                "question_template": "¬øCu√°l excede los l√≠mites razonables de hospitalidad empresarial?",
                "description": "Evaluar gastos de representaci√≥n y hospitalidad",
                "options_count": 4,
                "time_limit": 30
            },
            "contract_anomalies": {
                "question_template": "¬øCu√°l de estos t√©rminos contractuales sugiere irregularidades?",
                "description": "Detectar cl√°usulas sospechosas en contratos",
                "options_count": 3,
                "time_limit": 35
            }
        }
    
    def _load_cultural_scenarios(self) -> Dict[str, List[Dict[str, Any]]]:
        """Cargar escenarios culturales por categor√≠a"""
        
        return {
            "risk_classification": [
                {
                    "text": "Reuni√≥n de coordinaci√≥n con proveedor",
                    "risk_level": "LOW",
                    "cultural_markers": [],
                    "visual_cue": "üìã Reuni√≥n formal"
                },
                {
                    "text": "Un regalito de fin de a√±o para el inspector",
                    "risk_level": "HIGH", 
                    "cultural_markers": ["diminutivo_argentino", "funcionario_publico"],
                    "visual_cue": "üéÅ Regalo + üë®‚Äçüíº Funcionario"
                },
                {
                    "text": "Cena de trabajo con cliente potencial",
                    "risk_level": "MEDIUM",
                    "cultural_markers": ["hospitalidad_comercial"],
                    "visual_cue": "üçΩÔ∏è Cena de negocios"
                },
                {
                    "text": "Mi cu√±ado puede conseguirnos el contrato",
                    "risk_level": "HIGH",
                    "cultural_markers": ["familia_extendida", "trafico_influencias"],
                    "visual_cue": "üë®‚Äçüë®‚Äçüë¶ Familia + üìÑ Contrato"
                }
            ],
            "euphemism_detection": [
                {
                    "text": "Vamos a gestionar el tema con el municipio",
                    "is_euphemism": True,
                    "meaning": "Posible soborno o influencia irregular",
                    "visual_cue": "üèõÔ∏è Municipio + üí∞ Gesti√≥n"
                },
                {
                    "text": "Presentamos la documentaci√≥n requerida",
                    "is_euphemism": False,
                    "meaning": "Procedimiento normal",
                    "visual_cue": "üìÑ Documentos oficiales"
                },
                {
                    "text": "Lo acomodamos por izquierda como siempre",
                    "is_euphemism": True,
                    "meaning": "Procedimiento irregular habitual",
                    "visual_cue": "‚¨ÖÔ∏è Por izquierda + üîÑ Repetici√≥n"
                },
                {
                    "text": "Seguimos el proceso establecido en el reglamento",
                    "is_euphemism": False,
                    "meaning": "Cumplimiento normativo",
                    "visual_cue": "üìö Reglamento + ‚úÖ Cumplimiento"
                }
            ],
            "family_networks": [
                {
                    "text": "El director de compras es profesional independiente",
                    "has_conflict": False,
                    "relationship_type": "none",
                    "visual_cue": "üë§ Profesional independiente"
                },
                {
                    "text": "Mi hermano dirige la empresa contratista",
                    "has_conflict": True,
                    "relationship_type": "hermano",
                    "visual_cue": "üë¨ Hermanos + üè¢ Empresa"
                },
                {
                    "text": "El proveedor recomendado es primo del gerente",
                    "has_conflict": True,
                    "relationship_type": "primo",
                    "visual_cue": "üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ Primos + ü§ù Recomendaci√≥n"
                }
            ]
        }
    
    def _load_visual_elements(self) -> Dict[str, str]:
        """Cargar elementos visuales (emojis como placeholder)"""
        
        return {
            "high_risk": "üö®",
            "medium_risk": "‚ö†Ô∏è", 
            "low_risk": "‚úÖ",
            "family": "üë®‚Äçüë©‚Äçüëß‚Äçüë¶",
            "money": "üí∞",
            "government": "üèõÔ∏è",
            "business": "üè¢",
            "document": "üìÑ",
            "gift": "üéÅ",
            "meeting": "ü§ù",
            "dinner": "üçΩÔ∏è",
            "contract": "üìã"
        }
    
    def generate_visual_task(self, task_type: str, difficulty: int = 3) -> VisualTask:
        """Generar tarea visual de clasificaci√≥n"""
        
        if task_type not in self.task_templates:
            task_type = "risk_classification"  # Default
        
        template = self.task_templates[task_type]
        scenarios = self.cultural_scenarios.get(task_type, [])
        
        # Seleccionar escenarios seg√∫n dificultad
        selected_scenarios = self._select_scenarios_by_difficulty(scenarios, template["options_count"], difficulty)
        
        # Construir opciones
        options = []
        correct_answer = None
        
        for i, scenario in enumerate(selected_scenarios):
            option = {
                "id": f"option_{i+1}",
                "text": scenario["text"],
                "visual_cue": scenario.get("visual_cue", ""),
                "metadata": {
                    "cultural_markers": scenario.get("cultural_markers", []),
                    "risk_level": scenario.get("risk_level"),
                    "is_euphemism": scenario.get("is_euphemism"),
                    "has_conflict": scenario.get("has_conflict")
                }
            }
            options.append(option)
            
            # Determinar respuesta correcta seg√∫n tipo de tarea
            if task_type == "risk_classification" and scenario.get("risk_level") == "HIGH":
                correct_answer = option["id"]
            elif task_type == "euphemism_detection" and scenario.get("is_euphemism") == True:
                correct_answer = option["id"]
            elif task_type == "family_networks" and scenario.get("has_conflict") == True:
                correct_answer = option["id"]
        
        # Shufflear opciones
        random.shuffle(options)
        
        # Actualizar correct_answer despu√©s del shuffle
        if correct_answer:
            for option in options:
                if any(
                    (task_type == "risk_classification" and option["metadata"].get("risk_level") == "HIGH") or
                    (task_type == "euphemism_detection" and option["metadata"].get("is_euphemism") == True) or
                    (task_type == "family_networks" and option["metadata"].get("has_conflict") == True)
                    for _ in [None]  # Trick to make this work in any()
                ):
                    correct_answer = option["id"]
                    break
        
        task = VisualTask(
            task_id=str(uuid.uuid4()),
            task_type=task_type,
            question=template["question_template"],
            options=options,
            correct_answer=correct_answer,
            difficulty_level=difficulty,
            legal_reference="Art. 22 Ley 27.401"
        )
        
        return task
    
    def _select_scenarios_by_difficulty(self, scenarios: List[Dict[str, Any]], count: int, difficulty: int) -> List[Dict[str, Any]]:
        """Seleccionar escenarios basado en nivel de dificultad"""
        
        if difficulty <= 2:
            # F√°cil: incluir casos obvios
            high_risk = [s for s in scenarios if s.get("risk_level") == "HIGH" or s.get("is_euphemism") == True or s.get("has_conflict") == True]
            low_risk = [s for s in scenarios if s.get("risk_level") == "LOW" or s.get("is_euphemism") == False or s.get("has_conflict") == False]
            
            selected = high_risk[:1] + low_risk[:count-1]
            
        elif difficulty >= 4:
            # Dif√≠cil: casos ambiguos
            medium_risk = [s for s in scenarios if s.get("risk_level") == "MEDIUM"]
            others = [s for s in scenarios if s not in medium_risk]
            
            selected = medium_risk + others[:count-len(medium_risk)]
            
        else:
            # Medio: mix balanceado
            selected = random.sample(scenarios, min(count, len(scenarios)))
        
        # Completar si faltan opciones
        while len(selected) < count and scenarios:
            selected.append(random.choice(scenarios))
            
        # Si a√∫n faltan, duplicar existentes
        while len(selected) < count:
            if selected:
                selected.append(random.choice(selected))
            else:
                # Fallback scenario
                selected.append({
                    "text": "Procedimiento est√°ndar de la empresa",
                    "risk_level": "LOW",
                    "is_euphemism": False,
                    "has_conflict": False,
                    "cultural_markers": [],
                    "visual_cue": "‚úÖ Procedimiento normal"
                })
            
        return selected[:count]
    
    def validate_user_response(self, task: VisualTask, user_answer: str, response_time: float) -> Dict[str, Any]:
        """Validar respuesta del usuario"""
        
        is_correct = (task.correct_answer == user_answer)
        
        # Scoring basado en correctitud y tiempo
        base_score = 100 if is_correct else 0
        time_bonus = max(0, 30 - response_time) * 2  # Bonus por rapidez (max 30 seg)
        final_score = min(100, base_score + time_bonus)
        
        # Encontrar la opci√≥n seleccionada
        selected_option = None
        for option in task.options:
            if option["id"] == user_answer:
                selected_option = option
                break
        
        return {
            "is_correct": is_correct,
            "score": final_score,
            "response_time": response_time,
            "selected_option": selected_option,
            "correct_option": next((opt for opt in task.options if opt["id"] == task.correct_answer), None),
            "cultural_learning": self._generate_cultural_explanation(task, selected_option, is_correct)
        }
    
    def _generate_cultural_explanation(self, task: VisualTask, selected_option: Optional[Dict[str, Any]], is_correct: bool) -> str:
        """Generar explicaci√≥n cultural para el usuario"""
        
        if not selected_option:
            return "Respuesta no v√°lida."
        
        if is_correct:
            explanations = {
                "risk_classification": f"‚úÖ Correcto! '{selected_option['text']}' representa un riesgo alto porque contiene marcadores culturales argentinos que indican posible violaci√≥n de Ley 27.401.",
                "euphemism_detection": f"‚úÖ Correcto! '{selected_option['text']}' es un eufemismo t√≠pico argentino para encubrir actividades irregulares.",
                "family_networks": f"‚úÖ Correcto! Esta situaci√≥n indica conflicto de intereses por v√≠nculos familiares, muy com√∫n en contexto empresarial argentino."
            }
        else:
            explanations = {
                "risk_classification": f"‚ùå Incorrecto. '{selected_option['text']}' no es la opci√≥n de mayor riesgo. Las herramientas internacionales como SAP GRC tampoco detectar√≠an estos patrones culturales argentinos.",
                "euphemism_detection": f"‚ùå Incorrecto. '{selected_option['text']}' no es un eufemismo. En Argentina usamos expresiones espec√≠ficas para encubrir irregularidades que las herramientas globales no comprenden.",
                "family_networks": f"‚ùå Incorrecto. Esta situaci√≥n no presenta conflicto familiar directo. En Argentina, las redes familiares en negocios son m√°s sutiles que lo que detectan herramientas internacionales."
            }
        
        base_explanation = explanations.get(task.task_type, "An√°lisis cultural completado.")
        
        # Agregar contexto educativo
        educational_context = "\n\nüí° CORRUPTCHA detecta estos patrones √∫nicos que SAP GRC, PwC Risk y EY Compliance NO identifican porque no comprenden el contexto cultural argentino."
        
        return base_explanation + educational_context
    
    def generate_gamified_session(self, user_level: int = 1, session_length: int = 10) -> Dict[str, Any]:
        """Generar sesi√≥n gamificada de entrenamiento"""
        
        session = {
            "session_id": str(uuid.uuid4()),
            "user_level": user_level,
            "tasks": [],
            "total_score": 0,
            "cultural_intelligence_gained": 0,
            "session_stats": {
                "correct_answers": 0,
                "total_tasks": session_length,
                "avg_response_time": 0,
                "cultural_patterns_learned": set()
            }
        }
        
        # Generar tareas progresivas
        for i in range(session_length):
            # Aumentar dificultad gradualmente
            difficulty = min(5, user_level + (i // 3))
            
            # Variar tipos de tarea
            task_types = list(self.task_templates.keys())
            task_type = task_types[i % len(task_types)]
            
            task = self.generate_visual_task(task_type, difficulty)
            session["tasks"].append(asdict(task))
        
        return session

# Demo y testing
def demo_corruptcha_visual():
    """Demo del sistema de clasificaci√≥n visual CORRUPTCHA"""
    
    print("\n" + "="*100)
    print("üöÄ CORRUPTCHA VISUAL CLASSIFICATION - DEMO")
    print("Micro-tareas visuales estilo Google perro/muffin para compliance argentino")
    print("‚úÖ Inspirado en el modelo CAPTCHA de Google")
    print("="*100)
    
    engine = CorruptchaVisualEngine()
    
    # Generar diferentes tipos de tareas
    task_types = ["risk_classification", "euphemism_detection", "family_networks"]
    
    for i, task_type in enumerate(task_types, 1):
        print(f"\nüìä TAREA {i}: {task_type.upper().replace('_', ' ')}")
        print("-" * 60)
        
        # Generar tarea
        task = engine.generate_visual_task(task_type, difficulty=3)
        
        print(f"‚ùì {task.question}")
        print(f"üéØ Tipo: {task.task_type}")
        print(f"‚ö° Dificultad: {task.difficulty_level}/5")
        print(f"üìú Referencia: {task.legal_reference}")
        
        print(f"\nüìã OPCIONES:")
        for j, option in enumerate(task.options, 1):
            visual_cue = option.get("visual_cue", "")
            print(f"  {j}. {visual_cue} {option['text']}")
        
        # Simular respuesta correcta
        correct_option = next((opt for opt in task.options if opt["id"] == task.correct_answer), None)
        if correct_option:
            print(f"\n‚úÖ RESPUESTA CORRECTA: {correct_option['text']}")
        
        # Simular validaci√≥n
        response_time = random.uniform(5.0, 25.0)
        validation = engine.validate_user_response(task, task.correct_answer, response_time)
        
        print(f"üìä RESULTADO:")
        print(f"  ‚Ä¢ Correcto: {validation['is_correct']}")
        print(f"  ‚Ä¢ Score: {validation['score']}/100")
        print(f"  ‚Ä¢ Tiempo: {response_time:.1f}s")
        
        print(f"\nüí° EXPLICACI√ìN CULTURAL:")
        print(f"  {validation['cultural_learning']}")
    
    # Generar sesi√≥n gamificada
    print(f"\nüéÆ GENERANDO SESI√ìN GAMIFICADA:")
    print("-" * 60)
    
    session = engine.generate_gamified_session(user_level=2, session_length=5)
    
    print(f"Session ID: {session['session_id']}")
    print(f"Nivel usuario: {session['user_level']}")
    print(f"Total tareas: {session['session_stats']['total_tasks']}")
    
    print(f"\nüìã TAREAS EN LA SESI√ìN:")
    for i, task_data in enumerate(session['tasks'], 1):
        task_obj = VisualTask(**task_data)
        print(f"  {i}. {task_obj.task_type} (Dificultad {task_obj.difficulty_level})")
        print(f"     '{task_obj.question}'")
        print(f"     Opciones: {len(task_obj.options)}")
    
    print(f"\nüèÜ COMPARACI√ìN vs GOOGLE CAPTCHA:")
    print("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print("‚îÇ   GOOGLE CAPTCHA    ‚îÇ    CORRUPTCHA       ‚îÇ")  
    print("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    print("‚îÇ üêï vs üßÅ (perro/muffin) ‚îÇ üö® vs ‚úÖ (riesgo/normal)  ‚îÇ")
    print("‚îÇ Entrenamiento IA    ‚îÇ Inteligencia cultural‚îÇ")
    print("‚îÇ Reconocimiento      ‚îÇ Compliance argentino ‚îÇ")
    print("‚îÇ visual general      ‚îÇ espec√≠fico          ‚îÇ")
    print("‚îÇ Revenue: ads        ‚îÇ Revenue: B2B SaaS   ‚îÇ")
    print("‚îÇ Usuarios: millones  ‚îÇ Usuarios: empresas  ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    print(f"\nüí∞ MODELO DE MONETIZACI√ìN:")
    print("‚úÖ Empresas necesitan verificar compliance")
    print("‚úÖ Empleados clasifican casos reales argentinos")  
    print("‚úÖ Generamos dataset cultural √∫nico")
    print("‚úÖ Vendemos IA entrenada + datasets + APIs")
    print("‚úÖ Competimos vs SAP GRC con ventaja cultural")
    
    print(f"\nüöÄ VENTAJA vs HERRAMIENTAS INTERNACIONALES:")
    print("‚ùå SAP GRC: Busca 'bribery' ‚Üí No detecta 'regalito'")
    print("‚ùå PwC Risk: Busca 'corruption' ‚Üí No detecta 'por izquierda'")  
    print("‚ùå EY Compliance: Gen√©rico ‚Üí No detecta 'cu√±ado', 'primo'")
    print("‚úÖ CORRUPTCHA: Entrenado con CASOS REALES argentinos")
    print("‚úÖ Dataset cultural que NO EXISTE en mercado global")
    
    print(f"\n‚ö° PR√ìXIMOS PASOS:")
    print("1. üé® Crear interfaz visual real (React + Canvas)")
    print("2. üì± App m√≥vil para micro-tareas gamificadas")
    print("3. ü§ñ Integrar con Moonshot AI para an√°lisis avanzado")
    print("4. üìä Dashboard analytics para empresas")
    print("5. üåé Expansi√≥n: Brasil (jeitinho), Colombia, M√©xico")

if __name__ == "__main__":
    demo_corruptcha_visual()